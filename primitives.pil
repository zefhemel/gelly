import "ast.pil"
import "rewrite.pil"

import gel
import gelly::rewrite

Term gelly::rewrite::buildPattern = replaceMatchVar(new Parser("![ m_t ]").acceptExp(), "m_");
Term gelly::rewrite::matchPattern = replaceMatchVar(new Parser("?[ m_t ]").acceptExp(), "m_");
Term gelly::rewrite::importPattern = replaceMatchVar(new Parser("import m_fn").acceptExp(), "m_");
Term gelly::rewrite::seqPattern = replaceMatchVar(new Parser("m_f1; m_f2").acceptExp(), "m_");
Term gelly::rewrite::leftChoicePattern = replaceMatchVar(new Parser("m_f1 <+ m_f2").acceptExp(), "m_");
Term gelly::rewrite::strategyDefPattern = replaceMatchVar(new Parser("strategy m_name (m_strparam)[m_valparam] { m_steps }").acceptExp(), "m_");
Term gelly::rewrite::strategyCallPattern = replaceMatchVar(new Parser("m_name(m_strparam)[m_valparam]").acceptExp(), "m_");
Term gelly::rewrite::strategyCallNoStrParamPattern = replaceMatchVar(new Parser("m_name[m_valparam]").acceptExp(), "m_");
Term gelly::rewrite::strategyCallNoValParamPattern = replaceMatchVar(new Parser("m_name(m_strparam)").acceptExp(), "m_");
Term gelly::rewrite::strategyCallNoStrParamNoValParamPattern = replaceMatchVar(new Parser("m_name").acceptExp(), "m_");

Array<Function2<Bool, Term, Strategy>> gelly::rewrite::primitiveConstructs = new Array<Function2<Bool, Term, Strategy>>(
  Bool(Term t, Strategy i) { gelly::rewrite::prim::strategyCall(t, i) },
  Bool(Term t, Strategy i) { gelly::rewrite::prim::import(t, i) },
  Bool(Term t, Strategy i) { gelly::rewrite::prim::strategyDef(t, i) },
  Bool(Term t, Strategy i) { gelly::rewrite::prim::seq(t, i) },
  Bool(Term t, Strategy i) { gelly::rewrite::prim::leftChoice(t, i) },
  Bool(Term t, Strategy i) { gelly::rewrite::prim::build(t, i) },
  Bool(Term t, Strategy i) { gelly::rewrite::prim::match(t, i) }
);

Bool gelly::rewrite::prim::build(Term t, Strategy i) {
  var m = new Map<String, Term>();
  if(buildPattern.match(t, m)) {
    i.currentTerm = replaceMatchVar(m["m_t"], "m_").construct(i.bindings);
    return true;
  } else {
    return false;
  }
}

Bool gelly::rewrite::prim::strategyDef(Term t, Strategy i) {
  var m = new Map<String, Term>();
  if(strategyDefPattern.match(t, m)) {
    if(!(m["m_name"] instanceof SymbolTerm)) {
      return false;
    }
    String name = m["m_name"].as<SymbolTerm>.symbol;
    String strArgName = null;
    String valArgName = null;
    Bool valArgPassByValue = true;
    if(!(m["m_strparam"] instanceof EmptyTerm)) {
      strArgName = m["m_strparam"].as<SymbolTerm>.symbol;
    }
    if(!(m["m_valparam"] instanceof EmptyTerm)) {
      if(m["m_valparam"] instanceof SymbolTerm) {
        valArgName = m["m_valparam"].as<SymbolTerm>.symbol;
      } else {
        valArgName = m["m_valparam"].as<ConsTerm>.children[0].as<SymbolTerm>.symbol;
        valArgPassByValue = false;
      }
    }
    i.strategies[name] = new StrategyDef(strArgName, valArgName, valArgPassByValue, m["m_steps"]);
    return true;
  }
  return false;
}

Bool gelly::rewrite::prim::seq(Term t, Strategy i) {
  var passedOnce = false;
  while(t instanceof ConsTerm && t.as<ConsTerm>.constructor == ";") {
    var t2 = t.as<ConsTerm>;
    if(!i.eval(t2.children[0])) {
      return false;
    } else {
      t = t2.children[1];
    }
    passedOnce = true;
  }
  if(passedOnce) {
    return i.eval(t);
  } else {
    return false;
  }
}

Bool gelly::rewrite::prim::leftChoice(Term t, Strategy i) {
  var m = new Map<String, Term>();
  if(leftChoicePattern.match(t, m)) {
    if(i.eval(m["m_f1"])) {
      return true;
    } else {
      return i.eval(m["m_f2"]);
    }
  }
  return false;
}

class gelly::rewrite::StrArgStrategy {
  Term t = null;
  Strategy e = null;

  new(Strategy e, Term t) {
    this.e = e;
    this.t = t;
  }
}

Bool gelly::rewrite::prim::strategyCall(Term t, Strategy i) {
  var m = new Map<String, Term>();
  if(strategyCallNoStrParamPattern.match(t, m)) {
    m["m_strparam"] = new EmptyTerm();
  } else if(strategyCallNoValParamPattern.match(t, m)) {
    m["m_valparam"] = new EmptyTerm();
  } else if(strategyCallNoStrParamNoValParamPattern.match(t, m)) {
    if(m["m_name"] instanceof SymbolTerm) {
      m["m_valparam"] = new EmptyTerm();
      m["m_strparam"] = new EmptyTerm();
    } else {
      return false;
    }
  } else if(strategyCallPattern.match(t, m)) {
    // Nuthin'
  } else {
    return false;
  }
  var strategyName = m["m_name"].as<SymbolTerm>.symbol;
  if(strategyName == "debug") {
    if(!(m["m_valparam"] instanceof EmptyTerm)) {
      print(m["m_valparam"]);
    }
    println(i.currentTerm);
    return true;
  } else if(strategyName == "id") {
    return true;
  } else if(strategyName == "fail") {
    return false;
  } else if(strategyName == "eval") {
    var newStr = new Strategy(i.strategies.clone(), i.closureStrategies.clone(), i.bindings.clone());
    newStr.currentTerm = i.currentTerm;
    if(!newStr.eval(m["m_valparam"])) {
      return false;
    }
    return i.eval(newStr.currentTerm);
  } else if(strategyName == "all" || strategyName == "one") {
    if(i.currentTerm instanceof ConsTerm) {
      var stratT = m["m_strparam"];
      var successful = true;
      var newT = i.currentTerm.as<ConsTerm>.clone();
      var oldCurrentTerm = i.currentTerm;
      for(Int j = 0; j < newT.children.length; j++) {
        i.currentTerm = newT.children[j];
        if(strategyName == "all") {
          successful = successful && gelly::rewrite::prim::strategyCall(stratT, i);
        } else if(strategyName == "one") {
          if(gelly::rewrite::prim::strategyCall(stratT, i)) {
            newT.children[j] = i.currentTerm;
            i.currentTerm = newT;
            return true;
          } else {
            successful = false;
          }
        }
        if(successful) {
          newT.children[j] = i.currentTerm;
        }
      }
      if(successful) {
        i.currentTerm = newT;
        return true;
      } else {
        i.currentTerm = oldCurrentTerm;
        return false;
      }
    } else if(strategyName == "one") { // One fails on non-cons terms
      return false;
    } else {
      return true;
    }
  } else {
    if(i.strategies.contains(strategyName)) {
      var str = i.strategies[strategyName];
      var newStr = new Strategy(i.strategies.clone(), i.closureStrategies.clone(), new Map<String, Term>()); //i.bindings.clone()); //new Map<String, Term>());
      newStr.currentTerm = i.currentTerm;
      if(!(m["m_strparam"] instanceof EmptyTerm)) {
        newStr.closureStrategies[str.strArgName] = new ClosureStrategyDef(i, m["m_strparam"]);
      }
      if(!(m["m_valparam"] instanceof EmptyTerm)) {
        if(str.valArgPassByValue) {
          var oldT = i.currentTerm;
          if(!i.eval(m["m_valparam"])) {
            return false;
          }
          newStr.bindings[str.valArgName] = i.currentTerm;
          i.currentTerm = oldT;
        } else {
          newStr.bindings[str.valArgName] = m["m_valparam"];
        }
      }
      if(newStr.eval(str.t)) {
        i.currentTerm = newStr.currentTerm;
        return true;
      } else {
        return false;
      }
    } else if(i.closureStrategies.contains(strategyName)) {
      ClosureStrategyDef str = i.closureStrategies[strategyName];
      var newStr = new Strategy(str.parent.strategies, str.parent.closureStrategies, str.parent.bindings);
      newStr.currentTerm = i.currentTerm;
      if(newStr.eval(str.t)) {
        i.currentTerm = newStr.currentTerm;
        return true;
      } else {
        return false;
      }
    } else {
      println("No such strategy: " + strategyName);
    }
  }
  return false;
}

Bool gelly::rewrite::prim::match(Term t, Strategy i) {
  var m = new Map<String, Term>();
  if(matchPattern.match(t, m)) {
    var t2 = replaceMatchVar(m["m_t"], "m_");
    return t2.match(i.currentTerm, i.bindings);
  }
  return false;
}

Bool gelly::rewrite::prim::import(Term t, Strategy i) {
  var m = new Map<String, Term>();
  if(importPattern.match(t, m)) {
    //try {
      var filename = m["m_fn"].as<StringTerm>.value;
      var f = new pil::io::ReadFile(filename);
      var content = f.readAll();
      return i.evalString(content);
    //} catch(Exception e) {
      //println("Could not read file.");
    //}
  }
  return false;
}
