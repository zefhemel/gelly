import "ast.pil"
import "parser.pil"
//import "evaluator.pil"
import "rewrite.pil"
import "/Users/zef/svn/pil/src/lib/io.pil"

import gel
import gelly::rewrite

class gel::Interpreter {
  Term buildPattern = replaceMatchVar(new Parser("![ m_t ]").acceptExp(), "m_");
  Term matchPattern = replaceMatchVar(new Parser("?[ m_t ]").acceptExp(), "m_");
  Term rulePattern = replaceMatchVar(new Parser("m_rn : [ m_lh ] -> [ m_rh ]").acceptExp(), "m_");
  Term showBindingsPattern = new Parser(":bindings").acceptExp();
  Term showCurrentTermPattern = new Parser(":show").acceptExp();
  Term importPattern = replaceMatchVar(new Parser(":import m_fn").acceptExp(), "m_");

  Map<String, Term> ruleDefs = new Map<String, Term>();
  Term currentTerm = null;
  Map<String, Term> bindings = new Map<String, Term>();

  void evalBuild(Term t) {
    var m = new Map<String, Term>();
    if(buildPattern.match(t, m)) {
      currentTerm = m["m_t"];
      println("Current term set");
    }
  }

  void evalMatch(Term t) {
    var m = new Map<String, Term>();
    if(matchPattern.match(t, m)) {
      print("Match: ");
      var t2 = replaceMatchVar(m["m_t"], "m_");
      println(t2);
      if(t2.match(currentTerm, bindings)) {
        println(currentTerm);
        println("Current bindings: " + bindings.as<String>);
      } else {
        println("Match failed.");
      }
    }
  }

  void evalRuleDef(Term t) {
    var m = new Map<String, Term>();
    if(rulePattern.match(t, m)) {
      println("Defining rule!");
      println(m);
      ruleDefs[m["m_rn"].as<SymbolTerm>.symbol] = t;
    }
  }

  void evalShowBindings(Term t) {
    var m = new Map<String, Term>();
    if(showBindingsPattern.match(t, m)) {
      println(bindings);
    }
  }

  void evalImport(Term t) {
    var m = new Map<String, Term>();
    if(importPattern.match(t, m)) {
      try {
        var filename = m["m_fn"].as<StringTerm>.value;
        var f = new pil::io::ReadFile(filename);
        var content = f.readAll();
        handle(content);
      } catch(Exception e) {
        println("Could not read file.");
      }
    }
  }

  void evalShowCurrentTerm(Term t) {
    var m = new Map<String, Term>();
    if(showCurrentTermPattern.match(t, m)) {
      println(currentTerm);
    }
  }

  Term apply(String ruleName, Term t) {
    if(ruleDefs.contains(ruleName)) {
      var rule = ruleDefs[ruleName];
      var m = new Map<String, Term>();
      rulePattern.match(rule, m);
      var m2 = new Map<String, Term>();
      if(m["m_lh"].match(t, m2)) {
        currentTerm = m["m_rh"].construct(m2);
        return currentTerm;
      } else {
        throw new Exception("Could not apply!");
      }
    } else {
      throw new Exception("No rule named " + ruleName);
    }
  }

  void evalApply(Term t) {
    var m = new Map<String, Term>();
    if(t instanceof SymbolTerm) {
      var ruleName = t.as<SymbolTerm>.symbol;
      try {
        println(apply(ruleName, currentTerm));
      } catch(Exception e) {
        println("Application failed");
      }
    }
  }

  Term seqPattern = replaceMatchVar(new Parser("m_f1; m_f2").acceptExp(), "m_");
  void evalSeq(Term t) {
    var m = new Map<String, Term>();
    if(seqPattern.match(t, m)) {
      eval(m["m_f1"]);
      eval(m["m_f2"]);
    }
  }

  void eval(Term t) {
    evalSeq(t);
    evalBuild(t);
    evalMatch(t);
    evalRuleDef(t);
    evalApply(t);
    evalImport(t);
    evalShowBindings(t);
    evalShowCurrentTerm(t);
  }

  void handle(String input) {
    var p = new Parser(input);
    var t = p.acceptExp();
    if(t != null) {
      //println(t.toIndentedString(0));
      eval(t);
    }
  }
}

void main(Array<String> args) {
  //evalInit();
  String input = null;
  println("Welcome to gelly, type :q to quit.");
  var interp = new Interpreter();
  //interp.handle(":import \"test.g\"");
  while(input != ":q") {
    print("> ");
    input = readln();
    if(input != ":q") {
      println(new Parser(input).acceptExp().toIndentedString(0));
      //interp.eval(input);
    }
  }
  /*
  println(new Parser("if: 3 == 0").acceptExp().toIndentedString(0));
  println(new Parser("if 3 + if 8").acceptExp().toIndentedString(0));
  println(new Parser("say \"Zef\" to: out").acceptExp().toIndentedString(0));
  println(new Parser("a.b 20 + 8 + 4").acceptExp().toIndentedString(0));
  */
  /*
  var m = new Map<String, Term>();
  println(t.match(matchTerm, m));
  println(m);
  */
}
