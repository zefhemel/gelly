import "ast.pil"
import "parser.pil"
//import "evaluator.pil"
import "rewrite.pil"

import gel
import gelly::rewrite

class gel::Interpreter {
  Term buildPattern = replaceMatchVar(new Parser("![ m_t ]").acceptExp(), "m_");
  Term matchPattern = replaceMatchVar(new Parser("?[ m_t ]").acceptExp(), "m_");
  Term rulePattern = replaceMatchVar(new Parser("m_rn : [ m_lh ] -> [ m_rh ]").acceptExp(), "m_");
  Term showBindingsPattern = new Parser(":bindings").acceptExp();
  Term showCurrentTermPattern = new Parser(":show").acceptExp();

  Map<String, Term> ruleDefs = new Map<String, Term>();
  Term currentTerm = null;
  Map<String, Term> bindings = new Map<String, Term>();

  void handleBuild(Term t) {
    var m = new Map<String, Term>();
    if(buildPattern.match(t, m)) {
      currentTerm = m["m_t"];
      println("Current term set");
    }
  }

  void handleMatch(Term t) {
    var m = new Map<String, Term>();
    if(matchPattern.match(t, m)) {
      print("Match: ");
      var t2 = replaceMatchVar(m["m_t"], "m_");
      println(t2);
      if(t2.match(currentTerm, bindings)) {
        println(currentTerm);
        println("Current bindings: " + bindings.as<String>);
      } else {
        println("Match failed.");
      }
    }
  }

  void handleRuleDef(Term t) {
    var m = new Map<String, Term>();
    if(rulePattern.match(t, m)) {
      println("Defining rule!");
      println(m);
      ruleDefs[m["m_rn"].as<SymbolTerm>.symbol] = t;
    }
  }

  void handleShowBindings(Term t) {
    var m = new Map<String, Term>();
    if(showBindingsPattern.match(t, m)) {
      println(bindings);
    }
  }

  void handleShowCurrentTerm(Term t) {
    var m = new Map<String, Term>();
    if(showCurrentTermPattern.match(t, m)) {
      println(currentTerm);
    }
  }

  Term apply(String ruleName, Term t) {
    if(ruleDefs.contains(ruleName)) {
      var rule = ruleDefs[ruleName];
      var m = new Map<String, Term>();
      rulePattern.match(rule, m);
      var m2 = new Map<String, Term>();
      if(m["m_lh"].match(t, m2)) {
        currentTerm = m["m_rh"].construct(m2);
        return currentTerm;
      } else {
        throw new Exception("Could not apply!");
      }
    } else {
      throw new Exception("No rule named " + ruleName);
    }
  }

  void handleApply(Term t) {
    var m = new Map<String, Term>();
    if(t instanceof SymbolTerm) {
      var ruleName = t.as<SymbolTerm>.symbol;
      try {
        println(apply(ruleName, currentTerm));
      } catch(Exception e) {
        println("Application failed");
      }
    }
  }

  void handle(String input) {
    var p = new Parser(input);
    var t = p.acceptExp();
    if(t != null) {
      //println(t.toIndentedString(0));
      handleBuild(t);
      handleMatch(t);
      handleRuleDef(t);
      handleApply(t);
      handleShowBindings(t);
      handleShowCurrentTerm(t);
    }
  }
}

void main(Array<String> args) {
  //evalInit();
  String input = null;
  println("Welcome to gelly, type :q to quit.");
  var interp = new Interpreter();
  while(input != ":q") {
    print("> ");
    input = readln();
    if(input != ":q") {
      interp.handle(input);
    }
  }
  //println(replaceMatchVar(new Parser("3 * 8 + m_bla").acceptExp(), "m_").toIndentedString(0));
  /*
  var m = new Map<String, Term>();
  println(t.match(matchTerm, m));
  println(m);
  */
}
