import "ast.pil"
import "parser.pil"
import "utils.pil"
import "/Users/zef/svn/pil/src/lib/io.pil"

import gel
import gelly::utils
import gelly::rewrite

Array<Function2<Bool, Term, Strategy>> gelly::rewrite::primitives = new Array<Function2<Bool, Term, Strategy>>(
  Bool(Term t, Strategy i) { gelly::rewrite::prim::strategyCall(t, i) },
  Bool(Term t, Strategy i) { gelly::rewrite::prim::import(t, i) },
  Bool(Term t, Strategy i) { gelly::rewrite::prim::strategyDef(t, i) },
  Bool(Term t, Strategy i) { gelly::rewrite::prim::seq(t, i) },
  Bool(Term t, Strategy i) { gelly::rewrite::prim::leftChoice(t, i) },
  Bool(Term t, Strategy i) { gelly::rewrite::prim::build(t, i) },
  Bool(Term t, Strategy i) { gelly::rewrite::prim::match(t, i) }
);



Term gelly::rewrite::replaceMatchVar(Term t, String idnPrefix) {
  if(t instanceof SymbolTerm && stringStartsWith(t.as<SymbolTerm>.symbol, idnPrefix)) {
    return new MatchVarTerm(t.as<SymbolTerm>.symbol);
  } else if(t instanceof ConsTerm) {
    var t2 = t.as<ConsTerm>;
    var ct = t2.clone();
    for(Int i = 0; i < ct.children.length; i++) {
      ct.children[i] = replaceMatchVar(ct.children[i], idnPrefix);
    }
    return ct;
  }
  return t;
}

class gelly::rewrite::CouldNotInterpretException extends Exception {
  Term t = null;
  new(Term t) {
    this.t = t;
  }

  as<String> {
    return "Could not interpret: " + t.as<String>;
  }
}

class gelly::rewrite::StrategyDef {
  Term t = null;
  Array<String> strArgs = null;

  new(Array<String> strArgs, Term t) {
    this.strArgs = strArgs;
    this.t = t;
  }
}

class gelly::rewrite::ClosureStrategyDef {
  Term t = null;
  Strategy parent = null;

  new(Strategy parent, Term t) {
    this.parent = parent;
    this.t = t;
  }
}

class gelly::rewrite::Strategy {
  Term currentTerm = new EmptyTerm();
  Map<String, Term> bindings = null;
  Map<String, StrategyDef> strategies = null;
  Map<String, ClosureStrategyDef> closureStrategies = null;
  Strategy parent = null;

  new(Map<String, StrategyDef> strategies, Map<String, ClosureStrategyDef> closureStrategies, Map<String, Term> bindings) {
    this.strategies = strategies;
    this.closureStrategies = closureStrategies;
    this.bindings = bindings;
  }

  Bool eval(Term t) {
    if(t instanceof ConsTerm && t.as<ConsTerm>.constructor == "()") {
      t = t.as<ConsTerm>.children[0];
    }
    for(Function2<Bool, Term, Strategy> f : primitives) {
      if(f(t, this)) {
        return true;
      }
    }
    //throw new CouldNotInterpretException(t);
    return false;
  }

  Bool evalString(String input) {
    var p = new Parser(input);
    var t = p.acceptExp();
    if(t != null) {
      return eval(t);
    }
    return false;
  }
}
