import "ast.pil"
import "parser.pil"
import "utils.pil"
import "/Users/zef/svn/pil/src/lib/io.pil"
import "primitives.pil"

import gel
import gelly::utils
import gelly::rewrite

Term gelly::rewrite::replaceMatchVar(Term t) {
  if(t instanceof OpTerm && t.as<OpTerm>.op == "`" && t.as<OpTerm>.isPrefix()) {
    return new MatchVarTerm(t.as<OpTerm>.right.as<SymbolTerm>.symbol);
  } else if(t instanceof OpTerm) {
    var t2 = t.as<OpTerm>;
    var ct = t2.clone();
    if(!ct.isPrefix()) {
      ct.left = replaceMatchVar(ct.left);
    } 
    if(!ct.isPostfix()) {
      ct.right = replaceMatchVar(ct.right);
    }
    return ct;
  } else if(t instanceof GroupTerm) {
    var t2 = t.as<GroupTerm>;
    var ct = t2.clone();
    ct.group = replaceMatchVar(ct.group);
    return ct;
  }
  return t;
}

class gelly::rewrite::CouldNotInterpretException extends Exception {
  Term t = null;
  new(Term t) {
    this.t = t;
  }

  as<String> {
    return "Could not interpret: " + t.as<String>;
  }
}

class gelly::rewrite::StrategyDef {
  Term t = null;
  String strArgName = null;
  String valArgName = null;
  Bool valArgPassByValue = true;

  new(String strArgName, String valArgName, Bool valArgPassByValue, Term t) {
    this.strArgName = strArgName;
    this.valArgName = valArgName;
    this.valArgPassByValue = valArgPassByValue;
    this.t = t;
  }
}

class gelly::rewrite::ClosureStrategyDef {
  Term t = null;
  Strategy parent = null;

  new(Strategy parent, Term t) {
    this.parent = parent;
    this.t = t;
  }
}

class gelly::rewrite::Strategy {
  Term currentTerm = new EmptyTerm();
  Map<String, Term> bindings = null;
  Map<String, StrategyDef> strategies = null;
  Map<String, ClosureStrategyDef> closureStrategies = null;

  new(Map<String, StrategyDef> strategies, Map<String, ClosureStrategyDef> closureStrategies, Map<String, Term> bindings) {
    this.strategies = strategies;
    this.closureStrategies = closureStrategies;
    this.bindings = bindings;
  }

  Bool eval(Term t) {
    if(t instanceof GroupTerm && t.as<GroupTerm>.type == '(') {
      t = t.as<GroupTerm>.group;
    } else if(t instanceof EmptyTerm) {
      return true;
    }
    for(Function2<Bool, Term, Strategy> f : primitiveConstructs) {
      if(f(t, this)) {
        return true;
      }
    }
    //throw new CouldNotInterpretException(t);
    return false;
  }

  Bool evalString(String input) {
    var p = new Parser(input);
    var t = p.acceptExp();
    if(t != null) {
      return eval(t);
    }
    return false;
  }
}
