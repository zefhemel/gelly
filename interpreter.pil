import "ast.pil"
import "object.pil"
import "builtin/object.pil"
import "builtin/string.pil"
import "builtin/int.pil"
import "builtin/bool.pil"
import "builtin/native.pil"

import gelly
import gelly::exception

Map<String, GLClass> gelly::rootNamespace = new Map<String, GLClass>();


void gelly::initInterpreter() {
  rootNamespace["Object"] = gelly::builtin::object::init();
  var object = rootNamespace["Object"];
  var method = new GLClass(object, "Method");
  rootNamespace["Method"] = object;
  rootNamespace["String"] = gelly::builtin::string::init();
  rootNamespace["Int"] = gelly::builtin::int::init();
  rootNamespace["Bool"] = gelly::builtin::bool::init();
}


class gelly::Env {
  GLObject self = null;
  Map<String, GLObject> variables = new Map<String, GLObject>();
  GLObject returnValue = null;

  new(GLObject self) {
    this.self = self;
  }

  GLObject lookupVar(String var) {
    if(var == "self") {
      return self;
    } else if(variables.contains(var)) {
      return variables[var];
    } else if(rootNamespace.contains(var)) {
      return rootNamespace[var];
    } else {
      throw new Exception("Variable undefined: " + var);
    }
  }

  GLObject evalBlock(Term stats) {
    if(stats instanceof BlockTerm) {
      GLObject lastValue = null;
      for(Term t : stats.as<BlockTerm>.statements) {
        lastValue = evalStatement(t);
      }
      return lastValue;
    } else {
      throw new Exception("Can't handle: " + stats.as<String>);
    }
  }

  GLObject evalStatement(Term stat) {
    if(stat instanceof AssignTerm) {
      var assign = stat.as<AssignTerm>;
      variables[assign.lhs.as<IdnTerm>.idn] = evalExp(assign.value);
      return null;
    } else {
      return evalExp(stat);
    }
  }

  GLObject evalExp(Term exp) {
    if(exp instanceof IdnTerm) {
      return lookupVar(exp.as<IdnTerm>.idn);
    } else if(exp instanceof StringTerm) {
      return new GLString(exp.as<StringTerm>.value);
    } else if(exp instanceof IntTerm) {
      return new GLInt(exp.as<IntTerm>.value);
    } else if(exp instanceof BoolTerm) {
      return new GLBool(exp.as<BoolTerm>.value);
    } else if(exp instanceof BlockTerm) {
      var m = new GLMethod("noname", new Array<String>(), exp.as<BlockTerm>);
      m.closure = this;
      return m;
    } else if(exp instanceof MessageSendTerm) {
      var ms = exp.as<MessageSendTerm>;
      var o = evalExp(ms.object);
      var args = new Array<GLObject>(ms.arguments.length);
      for(Int i = 0; i < ms.arguments.length; i++) {
        args[i] = evalExp(ms.arguments[i]);
      }
      if(ms.selector == "return:") {
        returnValue = args[0];
        return returnValue;
      }
      var method = o.getMethod(ms.selector);
      if(method == null) {
        throw new NoSuchMethodException(ms.selector);
      }
      return method.invoke(o, args);
    } else {
      throw new Exception("Unsupported expression: " + exp.as<String>);
    }
  }

  Env lightClone(GLObject self) {
    var e = new Env(self);
    e.variables = variables;
    e.returnValue = returnValue;
    return e;
  }
}
