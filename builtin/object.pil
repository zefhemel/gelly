import "object.pil"

import gelly
import gelly::exception

GLClass gelly::builtin::object::init() {
  var object = new GLClass(null, "Object");

  object.methods["new"] = new gelly::builtin::object::NewInstanceMethod();
  object.methods["defineInstanceMethods:"] = new gelly::builtin::object::DefineMethods(true);
  object.methods["defineMethods:"] = new gelly::builtin::object::DefineMethods(false);
  object.methods["subClass:withMethods:"] = new gelly::builtin::object::SubclassMethod();

  object.instanceMethods["=="] = new gelly::builtin::object::EqMethod();
  object.instanceMethods["!="] = new gelly::builtin::object::NotEqMethod();

  object.instanceMethods["set:to:"] = new gelly::builtin::object::SetFieldMethod();
  object.instanceMethods["get:"] = new gelly::builtin::object::GetFieldMethod();
  object.instanceMethods["describe"] = new gelly::builtin::object::DescribeMethod();
  object.instanceMethods["defineMethods:"] = new gelly::builtin::object::DefineMethods(false);

  object.instanceMethods["print:"] = new gelly::builtin::object::PrintMethod();
  object.instanceMethods["if:then:"] = new gelly::builtin::object::IfThenMethod();
  object.instanceMethods["if:then:else:"] = new gelly::builtin::object::IfThenElseMethod();
  object.instanceMethods["while:do:"] = new gelly::builtin::object::WhileMethod();
  return object;
}

class gelly::builtin::object::NewInstanceMethod extends GLMethod {
  new() extends super("new", new Array<String>(), null) {
    this.cls = cls;
  }

  GLObject invoke(GLObject o, Array<GLObject> args) {
    return new GLObject(o.as<GLClass>);
  }
}

class gelly::builtin::object::SetFieldMethod extends GLMethod {
  new() extends super("set:to:", new Array<String>("fieldName", "value"), null) {
  }

  GLObject invoke(GLObject o, Array<GLObject> args) {
    var fieldName = args[0].as<GLString>.value;
    o.setField(fieldName, args[1]);
    return o;
  }
}

class gelly::builtin::object::GetFieldMethod extends GLMethod {
  new() extends super("get:", new Array<String>("fieldName"), null) {
  }

  GLObject invoke(GLObject o, Array<GLObject> args) {
    var fieldName = args[0].as<GLString>.value;
    return o.getField(fieldName);
  }
}

class gelly::builtin::object::DescribeMethod extends GLMethod {
  new() extends super("describe", new Array<String>(), null) {
  }

  GLObject invoke(GLObject o, Array<GLObject> args) {
    return new GLString(o.as<String>);
  }
}

class gelly::builtin::object::PrintMethod extends GLMethod {
  new() extends super("print:", new Array<String>("str"), null) {
  }

  GLObject invoke(GLObject o, Array<GLObject> args) {
    println(args[0].as<String>);
    return o;
  }
}

class gelly::builtin::object::DefineMethods extends GLMethod {
  Bool instanceMethods = true;

  new(Bool instanceMethods) extends super("defineMethods:", new Array<String>("methods"), null) {
    this.instanceMethods = instanceMethods;
  }

  GLObject invoke(GLObject self, Array<GLObject> args) {
    var method = args[0].as<GLMethod>;
    for(MethodDefTerm mdt : method.block.statements) {
      var newMethod = new GLMethod(mdt.signature.selector, mdt.signature.arguments, new BlockTerm(mdt.statements));
      if(self instanceof GLClass && instanceMethods) {
        self.as<GLClass>.instanceMethods[mdt.signature.selector] = newMethod;
      } else {
        self.methods[mdt.signature.selector] = newMethod;
      }
    }
    return self;
  }
}

class gelly::builtin::object::SubclassMethod extends GLMethod {
  new() extends super("subClass:withMethods:", new Array<String>("className", "methods"), null) {
  }

  GLObject invoke(GLObject self, Array<GLObject> args) {
    var className = args[0].as<GLString>.value;
    var definitions = args[1].as<GLMethod>; 
    var cls = new GLClass(self.as<GLClass>, className);
    for(MethodDefTerm mdt : definitions.block.statements) {
      var newMethod = new GLMethod(mdt.signature.selector, mdt.signature.arguments, new BlockTerm(mdt.statements));
      cls.instanceMethods[mdt.signature.selector] = newMethod;
    }
    rootNamespace[className] = cls;
    return cls;
  }
}

class gelly::builtin::object::EqMethod extends GLMethod {
  new() extends super("==", new Array<String>("other"), null) {
  }

  GLObject invoke(GLObject o, Array<GLObject> args) {
    return new GLBool(o == args[0]);
  }
}

class gelly::builtin::object::NotEqMethod extends GLMethod {
  new() extends super("!=", new Array<String>("other"), null) {
  }

  GLObject invoke(GLObject o, Array<GLObject> args) {
    return new GLBool(!(o == args[0]));
  }
}

class gelly::builtin::object::IfThenMethod extends GLMethod {
  new() extends super("if:then:", new Array<String>("condition", "ifTrue"), null) {
  }

  GLObject invoke(GLObject o, Array<GLObject> args) {
    verifyType(args[0], typeof GLMethod);
    verifyType(args[1], typeof GLMethod);
    GLMethod cond = args[0].as<GLMethod>;
    GLMethod trueBlock = args[1].as<GLMethod>;
    GLObject value = cond.invoke(o, new Array<GLObject>());
    if(!(value instanceof GLBool)) {
      throw new Exception("Condition should return in bool: " + cond.as<String>);
    }
    if(value.as<GLBool>.value) {
      return trueBlock.invoke(o, new Array<GLObject>());
    }
    return o;
  }
}

class gelly::builtin::object::IfThenElseMethod extends GLMethod {
  new() extends super("if:then:else:", new Array<String>("condition", "ifTrue", "ifFalse"), null) {
  }

  GLObject invoke(GLObject o, Array<GLObject> args) {
    verifyType(args[0], typeof GLMethod);
    verifyType(args[1], typeof GLMethod);
    verifyType(args[2], typeof GLMethod);
    GLMethod cond = args[0].as<GLMethod>;
    GLMethod trueBlock = args[1].as<GLMethod>;
    GLMethod falseBlock = args[2].as<GLMethod>;
    GLObject value = cond.invoke(o, new Array<GLObject>());
    if(!(value instanceof GLBool)) {
      throw new Exception("Condition should return in bool: " + cond.as<String>);
    }
    if(value.as<GLBool>.value) {
      return trueBlock.invoke(o, new Array<GLObject>());
    } else {
      return falseBlock.invoke(o, new Array<GLObject>());
    }
  }
}

class gelly::builtin::object::WhileMethod extends GLMethod {
  new() extends super("while:do:", new Array<String>("condition", "block"), null) {
  }

  GLObject invoke(GLObject o, Array<GLObject> args) {
    verifyType(args[0], typeof GLMethod);
    verifyType(args[1], typeof GLMethod);
    GLMethod cond = args[0].as<GLMethod>;
    GLMethod block = args[1].as<GLMethod>;
    GLObject value = cond.invoke(o, new Array<GLObject>());
    if(!(value instanceof GLBool)) {
      throw new Exception("Condition should return in bool: " + cond.as<String>);
    }
    while(value.as<GLBool>.value) {
      block.invoke(o, new Array<GLObject>());
      value = cond.invoke(o, new Array<GLObject>());
    }
    return o;
  }
}
